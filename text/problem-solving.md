# Ծրագրավորման խնդրի լուծման օրինակ

Ծրագրավորման լեզվին ծանոթ լինելը, բնականաբար, դեռևս բավարար չէ
ծրագրեր գրելու համար։ Ճիշտ այնպես, ինչպես որևէ բնական լեզվի
քերականություն իմանալը բավարար չէ գրագետ ու իմաստալից տեքստեր
գրելու համար։ Պետք է նաև ունենալ որոշակի բառապաշար և տիրապետել
տվյալ լեզվով նախադասություններ, դարձվածքներ ու բարդ բառեր կազմելու
հմտություններին ու հնարքներին։ Ծրագրավորման դեպքում էլ պետք է
տիրապետել ծրագրեր, ալգորիթմներ կազմելու հմտություններին ու
հնարքներին։

Ծրագրավորումը գործնական գիտություն է։ Մի կողմ թողնենք փիլիսոփայությունն
ու խոսենք օրինակով, ու դիտարկենք ցուցակում արժեքի _որոնման_ խնդիրը։ 
Ահա ձևակերպումը.

__Խնդիր։__ Սահմանել ֆունկցիա, որը պարզում է, թե արդյո՞ք տրված
արժեքն առկա է տրված ցուցակում։

Ի՞նչ անել։ Առանց երկար մտածելու. խնդիրը պահանջում է սահմանել 
ֆունկցիա։ Սահմանենք.

```Python
def search(value, elements):
    pass
```

Այս `pass`-ը Պիթոնի հրաման է, որը _ոչինչ_ չի անում. այն օգտագործվում
է հրամանների, ֆունկցիաների կամ դասերի _դատարկ_ մարմինները նշելու
համար։

Այս ֆունկցիան, իհարկե, կարող ենք կիրառել, օրինակ, `'հունվար'` արժեքի
և `['հունվար', 'փետրվար', 'մարտ', 'ապրիլ', 'մայիս', 'հունիս']` 
ցուցակի նկատմամբ։ Այսպես.

```Python
months = ['հունվար', 'փետրվար', 'մարտ', 'ապրիլ', 'մայիս', 'հունիս']
result = search('հունվար', months)
print(result)
```

Սակայն, պարզ է, որ ոչ մի արդյունք չենք ստանա. `result`-ը ստանալու է
`None` (ոչինչ) արժեքը։

Սահմանեցինք ֆունկցիա, ավելի ճիշտ՝ ֆունկցիայի վերանգիրը կամ կաղապարը։
Թեև այն դեռ ոչ մի օգտակար գործ չի անում, սակայն սա մի քայլ է դեպի 
խնդրի լուծումը։

Անցնենք առաջ։ Տարրերի ցուցակում մի որևէ արժեք փնտրելու համար պետք
է հերթականությամբ դիտարկել ցուցակի տարրերը և դրանցից ամեն մեկը 
համեմամտել որոնելի արժեքի հետ։ _Հերթականությամբ դիտարկել_ 
արտահայտությունը մեզ հուշում է, որ պետք է ինչ-որ միջոց, լեզվական
մեխանիզմ, որը հնարավորություն կտա անցնել ցուցակի տարրերով։ Այդ
միջոցը `for`-ն է՝ հետևյալ քերականությամբ.

```Python
for <փոփոխական> in <թվարկելի>:
    <մարմին>
```

Հիմա արդեն կարող ենք լրացնել մեր ֆունկցիայի մարմինը.

```Python
def search(value, elements):
    for el in elements:
        pass
```

Այս անգամ `pass`-ը՝ ոչինչ չանող հրամանը, `for`-ի մարմնում է, քանի
որ դեռ չենք որոշել, թե ինչ ենք գրելու այնտեղ։ Պարզ է, որ այս դեպքում 
էլ `search` ֆունկցիայի կիրառությունը ոչ մի օգտակար արժեք չի 
վերադարձնելու։ Պարզապես, համոզվելու համար, որ իսկապես `el`
փոփոխականն ընդունում է `elements` թվարկելի օբյեկտի բոլոր տարրերի
արժեքները, կարող ենք `pass`-ը փոխարինել `print()`-ով։

```Python
def search(value, elements):
    for el in elements:
        print(el)
```

Ու նորից մեր ֆունկցիան կիրառենք վերը բերված ցուցակի նկատմամբ.

```Python
search('հունվար', ['հունվար', 'փետրվար', 'մարտ', 'ապրիլ', 'մայիս', 'հունիս'])
```

Ստանալու ենք հետևյալ արտածումը, որից երևում է, որ, իսկապես, `el`-ը 
անցել է (նաև ասում են «վազել է») ցուցակի բոլոր տարրերով.

```
հունվար
փետրվար
մարտ
ապրիլ
մայիս
հունիս
```

Հիմա մնում է այս ընթացքը այն պահին, երբ `el`-ի ընթացիկ արժեքը 
հավասարվում է որոնելի `value` արժեքին։ Նորից ձևափոխենք մեր 
ֆունկցիան.

```Python
def search(value, elements):
    for el in elements:
        if el == value:
            return True
```

Եթե `search` ֆունկցիան կիրառենք վերը նշված արգումենտների նկատմամբ,
ապա կարտածվի `True` արժեքը։ Բայց եթե փորձենք ցուցակում «հունվար»-ի 
փոխարեն որոնել, օրինակ, «սեպտեմբեր» արժեքը, ապա կստանանք `None`
(ոչինչ)։ Կարելի է այսպես էլ թողնել՝ ֆունկցիայի վերադարձրած արժեքը
մեկնաբանելով. «եթե գտնվել է, ապա `True`, հակառակ դեպքում՝ `None`»։
Սակայն, տիպերի համաձայնեցվածության տեսակետից ճիշտ կլինի, որ
ֆունկցիան իր ավարտի բոլոր սցենարների դեպքում վերադարձնի նույն տիպի
արժեք։ Տվյալ դեպքում, պարզապես պետք է ֆունկցիայի վերջում ավելացնել
`return False` տողը։ Այսպես.

```Python
def search(value, elements):
    for el in elements:
        if el == value:
            return True
    return False
```

Այս կերպ արդեն `search` ֆունկցիան վերադարձնում է միայն _տրամաբանական_
տիպի արժեքներ՝ `True` կամ `False`։
